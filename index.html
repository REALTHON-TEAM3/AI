<!DOCTYPE html>
<html>
  <head>
    <title>Voice Chef AI (Realtime)</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f0f2f5;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
      }
      h1 {
        color: #333;
      }
      /* --- [ì¶”ê°€] íƒ€ì´ë¨¸ ë””ìì¸ --- */
      #timer-display {
        font-size: 4rem;
        font-weight: bold;
        color: #ff4757;
        margin: 20px 0;
        font-variant-numeric: tabular-nums; /* ìˆ«ìê°€ í”ë“¤ë¦¬ì§€ ì•Šê²Œ ê³ ì • */
        display: none; /* í‰ì†Œì—ëŠ” ìˆ¨ê¹€ */
      }
      /* --- [ì¶”ê°€] ë ˆì‹œí”¼ ê²€ìƒ‰ ë””ìì¸ --- */
      .search-section {
        margin-bottom: 15px;
        display: flex;
        gap: 10px;
        align-items: center;
      }
      input {
        padding: 10px;
        font-size: 16px;
        border: 1px solid #ddd;
        border-radius: 5px;
        width: 250px;
      }
      .label {
        font-weight: bold;
        width: 80px;
      }
      #status {
        margin-top: 20px;
        padding: 10px;
        border-radius: 5px;
        background-color: #fff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        font-weight: bold;
      }
      button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        margin: 10px;
        transition: background-color 0.3s;
      }
      button:hover {
        background-color: #0056b3;
      }
      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }
      #log {
        width: 80%;
        max-width: 600px;
        height: 300px;
        overflow-y: scroll;
        background: white;
        border: 1px solid #ddd;
        padding: 10px;
        margin-top: 20px;
        border-radius: 5px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <h1>âš¡ Voice Chef (Realtime API)</h1>

    <!-- 1. ìš”ë¦¬ ì´ë¦„ ê²€ìƒ‰ -->
    <div class="search-section">
      <span class="label">ìš”ë¦¬ ì´ë¦„:</span>
      <input type="text" id="menuInput" placeholder="ì˜ˆ: ê¹€ì¹˜ì°Œê°œ" />
      <button onclick="searchMenu()">ë ˆì‹œí”¼ ê²€ìƒ‰</button>
    </div>

    <!-- 2. ìœ íŠœë¸Œ ë§í¬ ê²€ìƒ‰ -->
    <div class="search-section">
      <span class="label">ìœ íŠœë¸Œ URL:</span>
      <input type="text" id="youtubeInput" placeholder="ìœ íŠœë¸Œ ë§í¬ ë¶™ì—¬ë„£ê¸°" />
      <button onclick="searchYoutube()">ì˜ìƒ ë¶„ì„</button>
    </div>

    <div id="timer-display">00:00</div>

    <div id="controls">
      <button id="startBtn" onclick="startSession()">Start Conversation</button>
      <button id="stopBtn" onclick="stopSession()" disabled>Stop</button>
    </div>
    <div id="status">Ready</div>
    <div id="log"></div>

    <script>
      let ws;
      let audioContext;
      let processor;
      let inputSource;
      let isRecording = false;
      let nextStartTime = 0;
      let timerInterval = null; // íƒ€ì´ë¨¸ ì¸í„°ë²Œ ë³€ìˆ˜

      // --- 1. ë©”ë‰´ ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰ ---
      async function searchMenu() {
        const menuName = document.getElementById("menuInput").value;
        if (!menuName) {
          alert("ìš”ë¦¬ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!");
          return;
        }
        await sendRecipeRequest(
          "/recipe",
          { menu_name: menuName },
          `ğŸ” ìš”ë¦¬ ê²€ìƒ‰: ${menuName}`
        );
      }

      // --- 2. ìœ íŠœë¸Œ ë§í¬ë¡œ ê²€ìƒ‰ ---
      async function searchYoutube() {
        const videoUrl = document.getElementById("youtubeInput").value;
        if (!videoUrl) {
          alert("ìœ íŠœë¸Œ ë§í¬ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!");
          return;
        }
        await sendRecipeRequest(
          "/youtube-recipe",
          { video_url: videoUrl },
          `ğŸ¥ ì˜ìƒ ë¶„ì„ ì‹œì‘: ${videoUrl}`
        );
      }

      // --- ê³µí†µ ìš”ì²­ í•¨ìˆ˜ ---
      async function sendRecipeRequest(endpoint, bodyData, logMessage) {
        log(logMessage);
        log("â³ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...");

        try {
          const response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(bodyData),
          });

          const result = await response.json();

          if (response.ok) {
            log("âœ… ë ˆì‹œí”¼ ì„¤ì • ì™„ë£Œ!");
            log("--------------------------------");
            log(`â±ï¸ ì˜ˆìƒ ì¡°ë¦¬ ì‹œê°„: ${result.estimated_time}ë¶„`);
            log("--------------------------------");
            alert(
              `ë ˆì‹œí”¼ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤! (ì˜ˆìƒ ì‹œê°„: ${result.estimated_time}ë¶„)\nì´ì œ ëŒ€í™”ë¥¼ ì‹œì‘í•˜ì„¸ìš”.`
            );
          } else {
            log(`âŒ ì—ëŸ¬: ${result.error}`);
            alert("ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë¡œê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.");
          }
        } catch (error) {
          log(`âŒ ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬: ${error}`);
          alert("ì„œë²„ ì—°ê²° ì‹¤íŒ¨");
        }
      }

      function log(message) {
        const logDiv = document.getElementById("log");
        const p = document.createElement("p");
        p.textContent = message;
        logDiv.appendChild(p);
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      function speakAlert(text) {
        if ("speechSynthesis" in window) {
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.lang = "ko-KR";
          utterance.rate = 1.0;
          window.speechSynthesis.speak(utterance);
        } else {
          alert(text);
        }
      }

      // --- [ì¶”ê°€] íƒ€ì´ë¨¸ ì¹´ìš´íŠ¸ë‹¤ìš´ í•¨ìˆ˜ ---
      function startCountdown(durationSeconds) {
        const display = document.getElementById("timer-display");
        display.style.display = "block"; // íƒ€ì´ë¨¸ ë³´ì´ê¸°

        let timer = durationSeconds;

        // ê¸°ì¡´ íƒ€ì´ë¨¸ê°€ ìˆë‹¤ë©´ ì œê±°
        if (timerInterval) clearInterval(timerInterval);

        updateDisplay(timer);

        timerInterval = setInterval(function () {
          timer--;
          updateDisplay(timer);

          if (timer <= 0) {
            clearInterval(timerInterval);
            display.textContent = "Done!";
            setTimeout(() => {
              display.style.display = "none";
            }, 5000); // 5ì´ˆ ë’¤ ìˆ¨ê¹€
          }
        }, 1000);
      }

      function updateDisplay(seconds) {
        const display = document.getElementById("timer-display");
        const minutes = parseInt(seconds / 60, 10);
        const secs = parseInt(seconds % 60, 10);

        display.textContent =
          (minutes < 10 ? "0" + minutes : minutes) +
          ":" +
          (secs < 10 ? "0" + secs : secs);
      }

      async function startSession() {
        document.getElementById("startBtn").disabled = true;
        document.getElementById("stopBtn").disabled = false;
        document.getElementById("status").textContent = "Connecting...";

        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
        ws.binaryType = "arraybuffer";

        ws.onopen = async () => {
          log("Connected to Server");
          document.getElementById("status").textContent =
            "Connected. Initializing Audio...";
          await startAudio();
        };

        ws.onmessage = async (event) => {
          const data = JSON.parse(event.data);

          if (data.type === "audio") {
            playAudioChunk(data.data);
          } else if (data.type === "text") {
            log("Chef: " + data.data);
          } else if (data.type === "timer_start") {
            // --- [ì¶”ê°€] íƒ€ì´ë¨¸ ì‹œì‘ ì‹ í˜¸ ë°›ìŒ ---
            log(`â° ${data.seconds}ì´ˆ íƒ€ì´ë¨¸ ì‹œì‘`);
            startCountdown(data.seconds);
          } else if (data.type === "timer_done") {
            log("â° " + data.message);
            speakAlert(data.message);
          } else if (data.type === "error") {
            log("Error: " + data.data);
          }
        };

        ws.onclose = () => {
          log("Connection closed");
          stopSession();
        };
      }

      async function startAudio() {
        try {
          if (!audioContext) {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          }
          if (audioContext.state === "suspended") {
            await audioContext.resume();
          }

          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              channelCount: 1,
              sampleRate: 24000,
              echoCancellation: true,
              noiseSuppression: true, // [ì¶”ê°€] ì¡ìŒ ì œê±°
              autoGainControl: true, // [ì¶”ê°€] ìë™ ë³¼ë¥¨ ì¡°ì ˆ
            },
          });

          log("Microphone access granted");
          document.getElementById("status").textContent =
            "Listening... (Speak now)";

          inputSource = audioContext.createMediaStreamSource(stream);
          processor = audioContext.createScriptProcessor(4096, 1, 1);

          processor.onaudioprocess = (e) => {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            const inputData = e.inputBuffer.getChannelData(0);
            const pcmData = new Int16Array(inputData.length);
            for (let i = 0; i < inputData.length; i++) {
              const s = Math.max(-1, Math.min(1, inputData[i]));
              pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
            }
            ws.send(pcmData.buffer);
          };

          inputSource.connect(processor);
          processor.connect(audioContext.destination);
          isRecording = true;
        } catch (err) {
          log("Audio Error: " + err);
          stopSession();
        }
      }

      function playAudioChunk(base64Data) {
        if (!audioContext) return;
        try {
          const binaryString = window.atob(base64Data);
          const len = binaryString.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const int16Data = new Int16Array(bytes.buffer);
          const float32Data = new Float32Array(int16Data.length);
          for (let i = 0; i < int16Data.length; i++) {
            float32Data[i] = int16Data[i] / 0x8000;
          }
          const buffer = audioContext.createBuffer(
            1,
            float32Data.length,
            24000
          );
          buffer.getChannelData(0).set(float32Data);
          const source = audioContext.createBufferSource();
          source.buffer = buffer;
          source.connect(audioContext.destination);
          const currentTime = audioContext.currentTime;
          if (nextStartTime < currentTime) {
            nextStartTime = currentTime;
          }
          source.start(nextStartTime);
          nextStartTime += buffer.duration;
          source.onended = () => {
            if (audioContext.currentTime >= nextStartTime) {
              document.getElementById("status").textContent = "Listening...";
            }
          };
        } catch (e) {
          log("Playback Error: " + e);
        }
      }

      function stopSession() {
        document.getElementById("startBtn").disabled = false;
        document.getElementById("stopBtn").disabled = true;
        document.getElementById("status").textContent = "Stopped";
        // íƒ€ì´ë¨¸ ì¸í„°ë²Œ ì •ì§€
        if (timerInterval) clearInterval(timerInterval);
        document.getElementById("timer-display").style.display = "none";

        if (processor) {
          processor.disconnect();
          processor = null;
        }
        if (inputSource) {
          inputSource.disconnect();
          inputSource = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        if (ws) {
          ws.close();
          ws = null;
        }
        isRecording = false;
      }
    </script>
  </body>
</html>
